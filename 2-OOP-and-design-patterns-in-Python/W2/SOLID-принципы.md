**Принцип единственной ответственности (The Single Responsibility Principle)**: у каждого объекта должна быть только одна ответственность. Все поведение этого объекта должно быть направлено на обеспечение этой ответственности и никаких других.  

**Принцип открытости/закрытости (The Open Closed Principle)**: классы должны быть открыты для расширения, но закрыты для изменения. Этот принцип является важным, потому что внесение изменений в существующие компоненты системы может также привести к непредвиденным изменения в работе самой этой системы. Однако поведение существующих объектов при необходимости можно расширить при помощи создания новых сущностей.

Рассмотрим на примере. Пусть существует класс Robot. У этого класса есть метод breake. Мы хотим создать робота, который при поломке кроме всего прочего включает аварийную сигнализацию alarm. При этом мы не должны переписывать сам класс Robot, а должны создать потомка AlarmRobot, который при вызове breake после вызова соответствующего метода родительского класса будет так же вызывать метод alarm.

**Принцип подстановки Барбары Лисков (The Liskov Substitution Principle)**: функции, которые используют базовый тип должны иметь возможность использовать его подтипы не зная об этом.  

**Принцип разделения интерфейса (The Interface Segregation Principle)**: клиенты не должны зависеть от методов, которые они не используют.  

**Принцип инверсии зависимостей (The Dependency Inversion Principle)**:

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Приведем пример. Пусть у вас есть базовый класс Distributer, который может отправлять сообщения в различные социальные сети. У этого класса есть несколько реализаций, например VKDistributer и OKDistributer. Согласно принципу инверсии зависимостей, эти реализации не должны зависеть от методов класса Distributer (например VK_send_message и OK_send_message). Вместо этого у класса Distributor должен быть объявлен общий абстрактный метод send_message, который и будет реализован отдельно в каждом из потомков.  
